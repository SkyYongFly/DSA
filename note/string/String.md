### 字符串匹配

#### 1 单模式串匹配的算法

一个串跟一个串进行匹配

##### 1.1 BF算法

* BF 是 Brute Force 的缩写，中文叫作**暴力匹配算法**，也叫**朴素匹配算法** ；

* 简单、好懂，但性能不高 ；

* **主串**和**模式串**：比如 我们在字符串 A 中查找字符串 B，那字符串 A 就是主串，字符串 B 就是模式串

* 思想：主串中，检查起始位置分别是 0、1、…n-m 且长度为 m 的 n-m+1个子串，看有没有跟模式串匹配的；

  <img src="images.assets/1586869230374.png" alt="1586869230374" style="zoom:80%;" />

* 最坏情况时间复杂度是 O(n * m) ；但实际处理时中途遇到不能匹配的字符的时候，就可以就停止了，不需要把 m 个字符都比对一下，所以实际效率一般比 O(n * m)高；

##### 1.2 RK算法

* Rabin-Karp 算法，BF 算法的改进；
* 思想
  * BF 算法在匹配的时候需要针对每个子串挨个字符和模式串匹配，模式串很长的话，耗时；
  * RK算法先**算出主串中每个子串对应的哈希值**，每次比较时候，先直接利用哈希值和模式串比较，很快速；
  * 如果哈希值相等，为避免哈希冲突，可以再详细对比下每个字符；
  * 如果不相等说明肯定不匹配，直接跳过；
  * 当然在主串计算哈希值的时候就直接和模式串比较，避免先算出所有再从头对比；不过如果匹配主串中所有子串就需要一直遍历完主串了。

* 哈希算法设计

  <img src="images.assets/1586871738473.png" alt="1586871738473" style="zoom:80%;" />

  哈希算法可根据实际设计，这里简单叙述下思想，计算每个子串哈希值的时候需要遍历每个字符，导致计算哈希值功能部分效率不高，其实我们可以根据前后子串的关联关系快速计算。

  例如上图，假设我们字符串只包含 a 到 z 26个字母，我们简单的将 a 到 z 按照 1 到 25 编号，子串的哈希值就是每个字符对应值和。第一个子串和第二个子串之间其实中间部分是重合的，那我们可以利用第一个子串的哈希值减去自己开头的字符值加上第二个子串的末尾字符值，快速算出第二个子串的值，依次类推……这个在子串比较长的时候很方便，例如

  ![1586872213168](images.assets/1586872213168.png)

  当然不同的哈希算法中间部分的内容不一定是相同的，但是最好设计成有关联关系，例如倍数关系。

  这样可在 O(n) 时间复杂度内计算出所有子串的哈希值。

* 时间复杂度

  整个 RK 算法包含两部分，**计算子串哈希值**和**模式串哈希值与子串哈希值之间的比较**。

  * 第一部分时间复杂度是 O(n)；

  * 每个子串与模式串比较 O(1)，总共比较 n-m+1 个子串，所以，这部分的时间复杂度也是 O(n) ;

  * 所以，RK 算法整体的时间复杂度就是 **O(n)**。

#### 2 多模式串匹配算法

在一个串中同时查找多个串

##### 2.1 Trie 树

##### 2.2 AC 自动机