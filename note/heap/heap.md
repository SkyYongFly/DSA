### 堆（Heap）和堆排序

#### 1 堆的定义

堆是一种特殊的树，需要满足以下两点：

- 堆是一个**完全二叉树**；
- 堆中每一个节点的值都必须**大于等于**（或**小于等于**）其子树中的**每个**节点的值。 按照递归的思想，也可以表述为**每个**子节点**大于等于**（或**小于等于**）其**左右**子节点的值。

每个节点大于等于子树中每个节点值的堆叫做**大顶堆**，小于等于则叫做**小顶堆**。
例如下面第一个小顶堆，第二个大顶堆：

<img src="images.assets/1585751370116.png" alt="1585751370116" style="zoom:50%;" />

<img src="images.assets/1585751531312.png" alt="1585751531312" style="zoom:50%;" />

#### 2 堆的存储

堆是完全二叉树，因此适合用数组来存储。下标为 i 的左子节点就是 i * 2 位置节点；右子节点就是 i * 2+1 位置节点；父节点就是 i/2 位置节点。

<img src="images.assets/1585752146975.png" alt="1585752146975" style="zoom:80%;" />



其实不管树也好、堆也好，这些复杂的数据结果本质上都是逻辑层的抽象，底层来说最基本的数据结构就两个：数组和链表，很多复杂的数据结构也是在这两个基本数据结构上面的封装和抽象，这个本身就取决于硬件层次的内存数据存储方式，内存中都是一个个块数据，那么对应高层次抽象的编程语言中也是，组织起来要么连续的内存空间即数组，要么分散但是逻辑上指针相连接的空间即链表。



这里堆上的这些数据可以用数组存储，也可以用左右指针节点类似链表存储，但是数组存储更节省空间。

可以反过来，其实我们要操作的数据就是这么一个数组中的数据，只不过为了特定场景，我们可以逻辑上映射成一个堆这么一个数据结构。

#### 3 堆的操作

以**大顶堆**为示例。

##### 3.1 插入元素

- 插入元素后需要继续满足堆的两个特性，例如将新插入元素放到堆的最后，如果不符合特性就需要调整让其满足堆的特性，这个过程叫做 **堆化**。

- 堆化分两种：从下往上、从上往下。

- 堆化操作：顺着节点所在路径，向上或者向下，对比，然后交换，例如大顶堆中子节点值比父节点大，那么就交换父子节点值。

- **示例**

  例如如下新插入元素 28：

  ![1585752858654](images.assets/1585752858654.png)

  新插入的元素直接放到数组末尾，新的堆需要判断是否满足还是一个堆，例子中明显新插入的节点28比它的父节点15大，那么不满足大顶堆要求，就需要进行堆化操作，直接交换15、28两个节点的值；

  交换后需要继续判断，发现 28 还是比现在的父节点 23 大，那么继续交换（这里交换可能担心父节点23的其它子节点，是否交换后28比父节点大，但是比左子节点小呢？这个不存在，原来父节点肯定比左右子节点大，那么现在自己比父节点大，那肯定比父左字节点大了）；

  交换后再比较，发现比父节点29小，那么就不需要再堆化了。

- **代码实现**

```java
/**
     * （大顶堆）堆中插入元素
     * @param data
     */
    public void insert(int data){
        // 首先判断堆是否已满
        if(n >= max){
            return;
        }

        // 将元素放到堆中最后一个节点
        heap[++n] = data;

        // 进行堆化处理，采用从下往上堆化
        int p = n;
        while (p / 2 >= 1 && heap[p] > heap[p / 2]){
            // 节点比父节点值大，则进行值交换
            int temp = heap[p];
            heap[p] = heap[p / 2];
            heap[p / 2] = temp;

            p = p / 2;
        }
    }
```

插入的时间复杂度，堆化从下往上，遍历路径顺着高度依次向上，所以**堆化的时间复杂度跟堆的高度成正比**，而堆作为完全二叉树高度不超过logn，因此插入元素时间复杂度是 **O(logn)** 。

