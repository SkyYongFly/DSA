### 堆（Heap）和堆排序

#### 1 堆的定义

堆是一种特殊的树，需要满足以下两点：

- 堆是一个**完全二叉树**；
- 堆中每一个节点的值都必须**大于等于**（或**小于等于**）其子树中的**每个**节点的值。 按照递归的思想，也可以表述为**每个**子节点**大于等于**（或**小于等于**）其**左右**子节点的值。

每个节点大于等于子树中每个节点值的堆叫做**大顶堆**，小于等于则叫做**小顶堆**。
例如下面第一个小顶堆，第二个大顶堆：

<img src="images.assets/1585751370116.png" alt="1585751370116" style="zoom:50%;" />

<img src="images.assets/1585751531312.png" alt="1585751531312" style="zoom:50%;" />

#### 2 堆的存储

堆是完全二叉树，因此适合用数组来存储。下标为 i 的左子节点就是 i * 2 位置节点；右子节点就是 i * 2+1 位置节点；父节点就是 i/2 位置节点。

<img src="images.assets/1585752146975.png" alt="1585752146975" style="zoom:80%;" />



其实不管树也好、堆也好，这些复杂的数据结果本质上都是逻辑层的抽象，底层来说最基本的数据结构就两个：数组和链表，很多复杂的数据结构也是在这两个基本数据结构上面的封装和抽象，这个本身就取决于硬件层次的内存数据存储方式，内存中都是一个个块数据，那么对应高层次抽象的编程语言中也是，组织起来要么连续的内存空间即数组，要么分散但是逻辑上指针相连接的空间即链表。



这里堆上的这些数据可以用数组存储，也可以用左右指针节点类似链表存储，但是数组存储更节省空间。

可以反过来，其实我们要操作的数据就是这么一个数组中的数据，只不过为了特定场景，我们可以逻辑上映射成一个堆这么一个数据结构。

#### 3 堆的操作

以**大顶堆**为示例。

##### 3.1 插入元素

- 插入元素后需要继续满足堆的两个特性，例如将新插入元素放到堆的最后，如果不符合特性就需要调整让其满足堆的特性，这个过程叫做 **堆化**。

- 堆化分两种：从下往上、从上往下。

- 堆化操作：顺着节点所在路径，向上或者向下，对比，然后交换，例如大顶堆中子节点值比父节点大，那么就交换父子节点值。

- **示例**

  例如如下新插入元素 28：

  ![1585752858654](images.assets/1585752858654.png)

  新插入的元素直接放到数组末尾，新的堆需要判断是否满足还是一个堆，例子中明显新插入的节点28比它的父节点15大，那么不满足大顶堆要求，就需要进行堆化操作，直接交换15、28两个节点的值；

  交换后需要继续判断，发现 28 还是比现在的父节点 23 大，那么继续交换（这里交换可能担心父节点23的其它子节点，是否交换后28比父节点大，但是比左子节点小呢？这个不存在，原来父节点肯定比左右子节点大，那么现在自己比父节点大，那肯定比父左字节点大了）；

  交换后再比较，发现比父节点29小，那么就不需要再堆化了。

- **代码实现**

```java
package com.skylaker.heap;


/**
 * 堆
 */
public class Heap {
    // 堆直接用数组存储
    private int[] heap ;

    // 堆中能存储的最大元素个数
    private int max;

    // 堆中已经存储的元素个数
    private int n;

    /**
     * 初始化构造堆
     * @param initLength 设置的堆最大容量
     */
    public Heap(int initLength){
        // 申请容量需要预留一个首空位置
        heap = new int[initLength + 1];
        max = initLength;
        n = 0;
    }


    /**
     * （大顶堆）堆中插入元素
     * @param data
     */
    public void insert(int data){
        // 首先判断堆是否已满
        if(n >= max){
            return;
        }

        // 将元素放到堆中最后一个节点
        heap[++n] = data;

        // 进行堆化处理，采用从下往上堆化
        int p = n;
        while (p / 2 >= 1 && heap[p] > heap[p / 2]){
            // 节点比父节点值大，则进行值交换
            int temp = heap[p];
            heap[p] = heap[p / 2];
            heap[p / 2] = temp;

            p = p / 2;
        }
    }
    
     /**
     * 打印输出
     */
    public void print(){
        if(0 == n){
            return;
        }

        for(int i = 1; i <= n; i++){
            System.out.print(heap[i] + " ");
        }
        System.out.println();
    }
}
```

* 时间复杂度

  插入的时间复杂度，堆化从下往上，遍历路径顺着高度依次向上，所以**堆化的时间复杂度跟堆的高度成正比**，而堆作为完全二叉树高度不超过logn，因此插入元素时间复杂度是 **O(logn)** 。

##### 3.2 删除堆顶元素

* 简述

  大顶堆中堆顶元素必然是最大值，小顶堆中堆顶元素必然是最小值。

  删除堆顶元素后，剩下的元素必须要维持堆这个数据结构，但是堆顶空缺了一个元素啊，咋办啊？两个思路：

  * 既然堆顶少了元素，那么我就直接补一个呗，而补的这个元素要作为堆顶元素，必然是剩下元素中最大值，而剩下元素最大值必然是之前堆顶的左右子节点中的一个，假设是左节点，左节点替补上后，那么原来左字节点这个位置又空缺了啊，那么仿照之前步骤继续剩下元素最大节点补充……但是这个方式又可能造成最后的叶子节点空缺，导致最后不是堆。

  * 删除堆顶元素，直接将最后一个元素补缺到堆顶，这样满足所有的节点是完全二叉树，然后再根据堆顶元素和左右子节点大小，选取出最大的值作为堆顶元素，依次向下堆化，例如：

    ![1585754565976](images.assets/1585754565976.png)

* 代码实现

  ```java
  	/**
       * 删除堆顶元素（大顶堆）
       */
      public void deleteMax(){
          // 边界检查
          if(n <= 0){
              return;
          }
  
          // 交换堆顶元素和最后一个元素值
          // 因为是删除堆顶元素，只需要将末尾元素放到堆顶
          heap[1] = heap[n];
          // 删除了一个元素，整体长度减一
          n--;
  
          // 进行自顶向下堆化处理
          int i = 1;
          while (true) {
              int maxPos = i;
  
              // 和两个子节点比较，找出最大的一个
              if(i*2 <= n && heap[maxPos] < heap[i * 2]) {
                  maxPos = i * 2;
              }
  
              if(i*2+1 <= n && heap[maxPos] < heap[i * 2 + 1]) {
                  maxPos = i * 2 + 1;
              }
  
              if (maxPos == i){
                  // 如果当前节点比左右子树节点都大，说明已经符合大顶堆要求，无需再处理
                  break;
              } else {
                  // 如果当前节点（父节点）比左右子树一个节点小，说明需要堆化，即交换节点
                  int temp = heap[i];
                  heap[i] = heap[maxPos];
                  heap[maxPos] = temp;
  
                  // 当前指向的节点需要跳到选取的较大值左右子节点位置
                  i = maxPos;
              }
          }
      }
  
      @Test
      public void testDeleteMax(){
          int[] arr = {29,23,18,17,15,1,5,6,8};
          Heap heap = new Heap(9);
          for(int a : arr){
              heap.insert(a);
          }
          heap.print();
          
          heap.deleteMax();
          heap.print();
          
          heap.deleteMax();
          heap.print();
      }
  ```
  
  测试构建如上图大顶堆，结果对应数组输出理论上应该是： 23、17、18、8、15、1、5、6，再删除一次堆顶，应该输出：18、17、6、8、15、1、5
  
  ![1585828634569](images.assets/1585828634569.png)

* 时间复杂度

  这里堆化自顶向下沿着路径比较交换，所以时间复杂度跟堆的高度成正比，即 **O(log n)**

#### 4 堆排序

##### 4.1 基本思想

* 借助于堆实现的排序算法就叫做堆排序；
* 其实我们排序的还是一堆数据，假设就数组吧，这些数据是无序的，那么要用堆实现排序，那不得首先有个堆啊，就是需要先将要排序的数据建立一个堆；建成之后呢？排序的最终目的是将数据按照从大到小或者从小到大（只谈数值数据大小）有序排列，就是要分出大小，那么建成的堆有什么特点呢？堆顶元素是最大值或者最小值！那么我们先取堆顶元素，剩下的元素再堆化成新的堆，再取堆顶元素，依次操作，最后不就能得到一个有序的数据集合了嘛 ！

##### 4.2 实现步骤

* 建堆

  先将待排序元素映射成完全二叉树，这个时候每个节点的值可能还不满足堆的大小关系，所以需要堆化成堆。

  需要从非叶子节点依次堆化，因为叶子节点不存在子节点，所以无需所谓的和子节点比较。

  ![1585839322851](images.assets/1585839322851.png)

* 排序

  建成堆之后，再依次取堆顶元素，这里大顶堆就是最大元素，每次取完剩下的元素需要重新堆化成新的大顶堆，再取堆顶，依次操作……

  ![1585839608234](images.assets/1585839608234.png)

![1585839676859](images.assets/1585839676859.png)

##### 	4.3 代码实现

```java
	/**
     * 堆排序
     * @param a 需要排序的数组，索引从 0 开始
     */
    public void heapSort(int[] a){
        if(null == a || 0 == a.length){
            return;
        }

        int length = a.length;

        // 1、建堆
        // 将数组映射成一个完全二叉树，但是还不满足堆的节点大小顺序要求，所以先堆化
        // 从非叶子节点开始
        heapMax(a);

        // 2、排序
        while (length >= 1){
            // 依次取堆顶元素，即大顶堆堆顶元素为最大值
            // 交换堆顶元素和末尾元素
            int temp = a[length - 1];
            a[length - 1] = a[0];
            a[0] = temp;

            // 索引位置往前移动一个，即剩下的元素堆化
            length--;

            // 每次剩下的元素要堆顶开始堆化（因为堆顶是之前末尾元素替换上去的）
            heapify(a, length , 0);
        }
    }

    /**
     * 任意一个数组建成大顶堆
     * @param a
     */
    public void heapMax(int[] a) {
        if (null == a || 0 == a.length) {
            return;
        }

        int length = a.length;

        // 将数组映射成一个完全二叉树，但是还不满足堆的节点大小顺序要求，所以先堆化
        // 从非叶子节点开始
        for (int i = (length-2)/2; i >= 0; i--) {
            heapify(a, length, i);
        }
    }

    /**
     * 堆化（从上往下）
     * @param a 目标数组 （元素从索引0开始）
     * @param length  数组长度
     * @param i 当前开始堆化的元素位置
     */
    private void heapify(int[] a, int length, int i) {
        while (true) {
            // 和左右两个子节点比较获取最大值节点
            // 并且需要判断左右子节点是否在范围内
            int maxPos = i;
            if(i*2+1 < length && a[maxPos] < a[i * 2 + 1]){
                maxPos = i * 2 + 1;
            }

            if(i*2+2 < length && a[maxPos] < a[i * 2 + 2]){
                maxPos = i * 2 + 2;
            }

            if(maxPos == i){
                // 最大是自身即父节点，满足大顶堆特性，结束
                break;
            } else {
                // 不满足，交换位置
                int temp = a[i];
                a[i] = a[maxPos];
                a[maxPos] = temp;

                // 继续向下比较
                i = maxPos;
            }
        }
    }
```

* 复杂度
  * 建堆时间复杂度 O(n) , 排序时间复杂度 O(n logn) , 整体堆排序时间复杂度 **O(n logn)**；
  * 原地排序算法；
  * 不是稳定排序算法，因为假设堆中元素都是同一个值，但是堆排序会直接交换首尾节点元素，自然就不符合稳定性要求了。