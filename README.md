#### 1. 开篇废话
##### 1.1 干了这碗鸡汤
**基础知识就像是一座大楼的地基，它决定了我们的技术高度。**

**人生路上，我们会遇到很多的坎。跨过去，你就可以成长，跨不过去就是困难和停滞。而在后面很长的一段时间里，你都需要为这个困难买单。**

##### 1.2 为什么学习数据结构与算法
* 掌握基础知识，便于运用
* 方便阅读框架源码，理解背后的设计思想
* 基础架构研发
* 建立时间复杂度、空间复杂度意识，写出高质量代码
 
##### 1.3 如何学习？
######  1）基本概念
* 数据结构：一组数据的存储结构
* 算法：操作数据的一组方法
######  2）相辅相成
数据结构是为算法服务的，算法要作用在特定的数据结构之上。

数据结构是静态的，只是组织数据的一种方式，如果不在其基础上操作，构建算法，孤立存在的数据结构是没用的。

数据结构和算法解决的是如何更省、更快地存储和处理数据的问题。

一个考量效率和资源消耗的方法，这就是复杂度分析方法，需要考虑：
时间复杂度、空间复杂度。
######  3) 基本内容
![913e0ababe43a2d57267df5c5f0832a7](README.resources/EDC38ABB-92D7-4D4E-90F4-A887C83C47F4.jpg)
######  4）重点内容
* 10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；
* 10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。
######  5）学习思路
学习它的“来历”“自身的特点”“适合解决的问题”以及“实际的应用场景"

掌握理论，动手编写，适度刷题，勤思考、多交流，反复迭代沉积。


#### 2. 复杂度分析
##### 2.1 概述
数据结构与算法本质上解决“快”和“省”的问题，即如何更快的运行代码、如何更节省存储空间。可用时间、空间复杂度来分析衡量。

时间、空间复杂度分析是从宏观角度去大体粗略估计程序的时间、空间消耗，和实际跑代码测试观察具体资源消耗是两种不同的思路。实际测试在不同的平台、环境下可能会有着不同的结果。

时间、空间复杂度分析也并不是说就完全准确的评估程序资源消耗，好比如开车从广州到北京，估算下大概需要的时间，那么就会根据正常开车来说大概速度，然后根据距离除以速度，再考虑下中间休息时间，那么就能得出一个大致的时间，但是你说实际路上跑的时候我就慢吞吞的开，那这种算是特殊情况，任何的估算都是一种近似推测。

当然时间、空间复杂度分析肯定不能直接替代实际的测试，我们在评估出相应的复杂度是为了优化代码，但是最终的效果如何，肯定还需要实际的测试，以达到两者结合来反馈实际效率的目的。

##### 2.2 大O复杂度表示法

###### 2.2.1  时间复杂度

**1）时间复杂度概述**

时间复杂度就是来衡量估算代码片段的执行时间，代码块由一行行的代码组成，总体的执行时间必然等于每行代码的执行时间之和，每行代码的执行时间尽管是不一样的，不过我们从整体估算的角度，代码整体执行次数越多那么执行时间也就越长，即 `总体执行时间 = 每行执行时间之和 = 代码行执行次数 * 每次执行平均时间`。

如果每次执行平均时间认为是近似的，其实总体执行时间必然和代码执行执行次数成正比例关系，注意这里不是说和代码行数成比例关系，而是代码行总的执行次数，例如有些代码行数看起来多，有100行，但是没有任何循环，每行执行一次；而有的代码就3行，但是是个循环，执行1万次，那么显然很大概率循环这个代码段执行时间长。
所以我们估算时间复杂度只需要看代码块执行次数即可。

如果用公式表示：`T(n)= O(f(n))`
其中 T(n) 表示代码执行时间；n 代表数据规模大小，不同大小的数据规模所消耗的执行时间肯定是不同的，n越大，则T(n)必然越大；f(n)代表代码执行次数总和，其实也就是每行代码执行次数总和；而大O正是表示总体时间与执行总次数的关系函数，即正比关系：f(n)越大，T(n)越大。

大O表示代码执行时间随数据规模增长的变化趋势，表示的是一种外在函数关系，但是具体说是啥函数关系，是 T(n)= 2 * f(n) 还是说 T(n) = f(n) + 10 呢，这个取决于不同的具体代码段，但是可以肯定的是一定是正比关系。

在分析时间复杂度过程中，可以忽略常数、低阶、系数，记录最大阶的量级即可。例如函数 
```math
T(n)=2n^{2} + 3n + 100
```
这个里面随着n的增大，那么整体的函数变化趋势主要就取决于n平方这个量级了，所以我们可以近似表示为： 
```math
T(n)=n^{2}
```
这个其实就是时间复杂度的一个量级表示。

**2）复杂度分析方法**

a. 关注循环次数最多的部分

在一个代码段中，其他部分几乎都是运算几次的程序，但是存在一个乃至多个循环，那么自然代码段的整体运行时间大概率取决于循环片段代码的执行次数，例如：

```
 int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }
```

循环之前代码行执行两次，循环部分执行 2n次（忽略每行实际多次，即一行执行一次的话就是1），那么整体其实取决于循环部分，则整体时间复杂度为  T(n) = O(n) 

b. 加法法则：总的复杂度取决于量级最大的代码复杂度

如果存在多个循环呢？例如：

```
int cal(int n) {
   int sum_1 = 0;
   int p = 1;
   for (; p < 100; ++p) {
     sum_1 = sum_1 + p;
   }
 
   int sum_3 = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1; 
     for (; j <= n; ++j) {
       sum_3 = sum_3 +  i * j;
     }
   }
 
   return sum_1 + sum_3;
 }
```

除去常量级运算，包含两个循环一个循环n次，一个循环n方次，那么总体时间复杂度其实可表示为：
```math
T(n)=O(n + n^{2})
```
这里面明显n方的量级要大于n，当n很大的时候，消耗时间主要取决于n方，可以忽略n，所以该段代码时间复杂度就是：
```math
T(n)=O(n^{2})
```
另外如果两个代码段，一个n次，一个m次，无法确定到底哪个大，那么其实整个的时间复杂度就是：
```math
T(n)=O(n + m)
```

c. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

如果一个循环代码片段执行n次，但是循环内部又调用其他函数，其他函数每次执行m次，那么总体的时间复杂度其实就是两者的乘积，例如：

```
int cal(int n) {
   for (; i < n; ++i) {
     ret = ret + f(i);
   } 
 } 
 
 int f(int m) {
  for (; i < m; ++i) {
    sum = sum + i;
  } 
  return sum;
 }
```

那么整体时间复杂度即：
```math
T(n) = O(f(n)) * O(f(m)) = O(n) * O(m) = O(n * m)
```

3）几种常见复杂度量级

* 常量阶 O(1)
* 对数阶 O(logn)
* 线性阶 O(n)
* 线性对数阶 O(nlogn)
* 平方阶 O(n^2) 、立方阶O(n^3) …… k次方阶O(n^k)
* 指数阶 O(2^n)
* 阶乘阶 O(n!)

其中像指数阶 O(2^n) 和阶乘阶 O(n!) 属于非多项式阶，其它的属于多项式阶，按照函数的特性我们看下几种复杂度的函数变化趋势：

![5b5ad09c19cfa13e44488e4a64466033](README.resources/58C14496-5BEC-446C-9AD6-770D876D62F3.png)

可以看出n的k次阶、指数阶、阶乘阶这些都是随着n的增大急速增长，这个在实际代码中意味着需要消耗着更多的时间，即程序效率低。

* 常量阶 O(1)

常量阶不是说就代表我们的程序就运行一次，而是运行的次数是有限次数的，不管n如何变化，它的次数是一定的，一般程序中没有循环、递归这些情况，不管有多少行。例如：

```
int count(int n) {
    int sum = 0;
    sum += n;
}
```

* 对数阶 O(logn)

这个难分析，直接看实例，例如：
```
 i=1;
 while (i <= n)  {
   i = i * 2;
 }
```

我们分析时间复杂度主要看代码执行次数，那么这里有循环，那肯定主要看循环的执行次数了，一眼看上去不知道有几次，可以传入实际的数值看看，例如 n = 10，那么判断的过程就是：

i = 1 ，i <= 10 ,  i = 1 * 2 = 2       第1次；
i = 2 ，i <= 10 ,  i = 2 * 2 = 4       第2次；
i = 4 ，i <= 10 ,  i = 4 * 2 = 8       第3次；
i = 8 ，i <= 10 ,  i = 8 * 2 = 16     第4次；
i = 16，i <= 10   			       不成立，结束

如果我们加大n的值，同样可以依次来计算下，其实发现，最终这个循环能执行次数即：
`2^0 , 2^1 , 2^2 , 2^3 , 2^4 , 2^5 …… 2^k —> n`
即2的执行次数方趋向于n的值，最终就是 2^k = n，k即为执行次数，而这里 k = log2N = logN

这里是以2为底的对数阶，其实不管代码是3的对数阶还是更大的对数阶，都可以当成2的对数阶，因为例如
log3N = log3 ^ 2 * log2N，而时间复杂度分析中系数是可以忽略的。

###### 2.2.2  空间复杂度

前面分析的时间复杂度就是分析代码消耗的时间，那么空间复杂度诚然分析的就是代码占用的空间资源大小。我们在代码运行过程中申请的内存空间就是所占用的空间资源，例如我们声明一个变量 i = 0，那么必然在JVM中需要分配一个空间去保存这个变量，也即是占用了一个单位内存空间，所以我们要分析空间复杂度，主要就要看程序申请分配了多少变量空间。例如：

```
void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i <n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i >= 0; --i) {
    print out a[i]
  }
}
```

这里申请了一个变量 i 和 一个大小 n 的数组，那么类似时间复杂度表示法我们可以认为当前程序空间复杂度就是 n + 1,同样常量阶不考虑，那么其实就是 n，即
```math
S(n) = O(n)
```

S(n) 代表空间复杂度，n代表数据规模，大O表示数据规模与空间复杂度的正比关系。

常见空间复杂度有 O(1)、O(n)、O(n^2) 。

##### 2.3 最好、最坏、均摊时间复杂度
##### 2.3.1 概述
某些场景下，算法的时间复杂度是不确定的，可能不同条件走不同的分支，那么仅用前面说的时间复杂度是无法全面的反应其时间复杂度的，所以就有了最好、最坏、平均、均摊时间复杂度这些不同角度的衡量指标。

##### 2.3.2 最好时间复杂度
最好时间复杂度即算法在最优化方案之下或最理想情况、花费时间最少的时间复杂度。

例如：要在数组a中找出指定值得元素所在位置
```
int find(int[] array, int val){
    // TODO 判空

    for(int i = 0; i < array.length; i++){
        if(val == array[i]){
            return i;
        }
    }
    
    return -1;
}
```

无法确定元素在数组中具体哪个位置，采用从前到后依次遍历（当然也可用用其它类似二分查找这些算法）方式的时候，如果第一个元素值就是目标值，那么只需要比较1次直接返回，如果最后位置则循环n次，如果不在数组中也需要n次。对于第一个位置情况显然时间复杂度就是O(1), 这也是最理想的情况，即最好时间复杂度。

##### 2.3.3 最坏时间复杂度
还是上面的例子，目标元素值在最后或者不在数组当中那么就需要循环n次，这种就是最不理想的情况，需要花费最多的时间，时间复杂度为O(n), 这也就是最坏时间复杂度的一个例子。

一般分析的时候比如对于循环这些最坏的情况都是要整个都循环完成，最好的情况就是在某个场景下能及早的退出循环。

##### 2.3.4 平均时间复杂度
上面最好、最坏时间复杂度反应的是极端情况下的，可能很多时候不会出现这些情况，那么就需要评估一个平均时间复杂度。可以通过加权平均来计算。

以上个例子，目标元素可能在数组中任意位置，在任意位置的概率为1/n；而每个位置要么不是目标值要么是，则符合概率为1/2；出现在第一个位置循环1次，第二个位置循环2次，依次类推，我们将所有元素位置和不在数组中概率加起来则就是：
```math
\frac{1}{n}*\frac{1}{2}*1 + \frac{1}{n}*\frac{1}{2}*2 + ... + \frac{1}{n}*\frac{1}{2}*n + \frac{1}{2}*n  = \frac{3n+1}{4}
```
计算出的结果为 (3n+1)/4，按照时间复杂度量级就是O(n)

平均时间复杂度又称加权平均时间复杂度或者期望时间复杂度。

##### 2.3.5 均摊时间复杂度
摊还分析得出的时间复杂度叫做均摊时间复杂度。

使用场景：大部分情况下时间复杂度都很低，但是个别场景下时间复杂较高，而且存在先后时序关系，我们可以采用摊还分析，即将耗时的操作时间分摊到每个耗时时间少的的操作上，这样整体的时间复杂度就会趋于平摊，也相当于一种平均时间复杂度了。如果很多时候都是最好时间复杂度，但是个别情况很耗时，但是由于总体时间少，所以可以忽略最耗时的了或者说最耗时的被平均了，最后均摊时间复杂度就是最好时间复杂度了。

例如：输入数组和不大于数组长度的非负整数val值，如果小于数组长度则输出val值，如果等于则遍历输出每个元素值
```
void find(int[] array, int val){
    if(val < array.length){
        输出 val值；
    }
    
    if(val == array.length){
      for(int i = 0; i < array.length; i++){
        输出 array[i];
      }
    }
}
```

这里输入的val值可能情况就是 0、1、2 ... n ，其实在小于n的时候时间复杂度都是O(1)，但是在为n的时候就是O(n)了，那么整体时间复杂度就是：
```math
\frac{1}{n+1}*1+\frac{1}{n+1}*1+...+\frac{1}{n+1}*n = \frac{2n}{n+1}
```
可见最终时间复杂度就是O(1), 其实不通过概率计算直接用摊还分析即可，最差的时候O(n)，那么我把这n次分到其他n个的O(1)上，相当于每个就是O(2)了，那最终还是O(1)量级时间复杂度。

#### 3. 基础数据结构与算法
##### 3.1 数组
定义：数组（Array）是一种线性表结构，用一组连续的内存空间，来存储一组具有相同类型的数据。

图示：例如我们申请了一个大小空间为7的字符数组（Java中），假设内存分配给数组的初始地址为100，每个字符占两字节

![73f9f2c2f715f9dc673db50b1cdf632f](README.resources/44E0F614-657D-4E6D-BCA2-1B2BA0F9A678.png)

寻址公式：`第i+1位地址 = 首地址 + i * 每个元素大小`
例如上例第4个元素地址就是 100 + 3*2 = 106

从0开始编号：方便寻址，减少寻址运算；历史原因。

查找时间复杂度：
a. 按照下标随机访问：O(1)
b. 查找指定元素元素：最好O(1)、最差O(n)、平均O(n)、二分查找O(logn)

插入操作
a. 将某个元素插入到数组中的第K个位置：
最好 -- 直接插入末尾 O(1)
最差 -- 数组开头位置，因为涉及后续元素往后移动 O(n)
平均 -- O(n)

![1f88d9da26ff09f5dea763377fca5355](README.resources/7E33CC2A-8332-4228-9672-EC0BE06B97AE.png)

优化插入操作：将原位置元素放入末尾，原位置插入目标元素，时间复杂度O(1)

![6e73e53fc29eb2e1312fa46be898d0bb](README.resources/17167BB6-0F59-4B23-8B73-018B23527A0A.png)

删除操作：删除第K位的元素，为保证内存连续性也要搬移数据
最好 -- 直接删除末尾 O(1)
最差 -- 数组开头位置，因为涉及后续元素往后移动 O(n)
平均 -- O(n)
优化 -- 每次删除时候并不真正删除元素，而是标记为已删除，当存储空间不够时候再执行真正的删除并搬移数据，减少每次都搬移数据的时间消耗

数组访问越界：
C语言即使越界了但是只要内存空间可以访问就能正常运行，可能导致隐含bug；例如C语言中：元素向下压栈分配内存空间，i、a[2]、a[1]、a[0]，越界后a[3]就是i位置，结果i又变为0，导致死循环（和编译器有关，开启堆栈保护功能设置可避免）
```
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}
```

Java语言具有显式越界检查，避免越界问题。

容器：例如ArrayList底层就是数组，对数组的操作进行了封装;
为避免集合频繁扩容影响性能最好提前预估设置好容量大小；
集合无法存储基本类型，基本类型还需要使用数组；
表示多维数组使用数组更简单；

##### 3.2 链表
###### 3.2.1 基本定义

定义：通过指针将零散的（不一定非连续）内存块串联在一起的数据结构。

![899c488b3a983fb660dcabf3fe62f499](README.resources/0DE45C67-4D2C-47DB-9D16-7FE195928703.png)

含义解读：

* 指针：可以理解为储存地址的变量，例如变量P，那么 *P 就是指针声明方式，含义为它代表它所指向地址的变对象；可以理解为Java中的引用：变量Person per = new Person() 变量per本身是引用变量，可能是局部变量，而它实际保存的是所指向对象的地址，即 per 是指向 new Person()出来的这个对象实例的。例如上图*p 指向链表头节点，那么就可以用*p来指代当前链表。

* 非连续：不同于数组要求连续的内存空间，零散的空间即可，有利于空间利用；

* 节点：链表节点同数组一样也是一个个内存块；只不过链表的节点不像数组的节点只有数据，还需要单独一个内存块来存储下一个节点的值；

* 把记录下个节点地址的指针叫做后继指针；

* 链表第一个节点叫做头结点；最后一个节点叫做尾节点；尾节点的后继指针指向空地址NULL，其实就是没存任何地址；

* 我们定义的数组也好，链表也罢，它们在实际内存中的形式都是一样的，都是一个个内存块，不过任务抽象把它们封装成不同的数据结构，例如链表这个前后连接的线肯定不存在，但是从逻辑上存在的，好像一根根线连接起来一样；

* 链表相比数组需要占据更多的内存空间，天然支持动态扩容，但是具体场景选用那种数据结构需要根据实际情况分析；

###### 3.2.2 单链表操作

* 插入节点

![ce9916d3d3ddc946ac1e0938b896eb7d](README.resources/9F431A24-4583-493F-A0FE-95342A818973.png)

单纯的插入操作本身：时间复杂度 O(1)

在指定节点之后插入节点： 时间复杂度 O(1)

在指定节点之前插入节点： 时间复杂度 O(n)

在指定值节点之前、后插入节点： 时间复杂度 O(n)

* 删除节点

![aac3e3c4064f80cccdd0398f58a63baa](README.resources/EF9AA38A-49E3-4116-9731-C37FB1544940.png)

单纯的删除操作本身：时间复杂度 O(1)

删除给定指针指向的节点：时间复杂度 O(n)，因为删除需要知道指定节点的前驱节点，单链表需要依次遍历直到 p->next = q 找到前驱节点才能删除，查找 O(n) ，删除 O(1)，加起来 O(n)

删除节点中值为某个值的节点：时间复杂度 O(n)，查找节点O(n)，删除操作O(1)，加起来就是 O(n)

* 访问节点

随机访问第K个节点：时间复杂度O(n)，因为链表空间非连续，无法类似数组寻址公式寻找节点，需要从头节点依次遍历

###### 3.2.3 循环链表

循环链表即在单链表的基础上，尾节点指向头节点：

![966a3c671283fbda028335a7984b04f4](README.resources/A33BB7C0-2FBF-4149-9207-90C77739DBF3.png)

###### 3.2.4 双向链表

后继指针next指向下一个节点，前驱指针prev指向前面的节点

![fcfebcc26f1f11817052cc3bd207a9f1](README.resources/90C1718D-7FB6-4B8A-B830-6905AF0FBD8F.png)

相比单链表需要更多的存储空间；但是支持前后双向遍历，支持O(1)时间复杂度找到前驱节点

* 插入节点

单纯的插入操作本身：时间复杂度 O(1)

在指定节点之后插入节点： 时间复杂度 O(1)

在指定节点之前插入节点： 时间复杂度 O(1)

在指定值节点之前、后插入节点： 时间复杂度 O(n)

* 删除节点

单纯的删除操作本身：时间复杂度 O(1)

删除给定指针指向的节点：时间复杂度 O(1)

删除节点中值为某个值的节点：时间复杂度 O(n)，查找节点O(n)，删除操作O(1)，加起来就是 O(n)

* 访问节点

随机访问第K个节点：同单链表一样 时间复杂度O(n)

###### 3.2.5 双向循环链表

![ae839c951c4942c60d7c9edcfdb7a203](README.resources/CDE14078-C41D-42FE-9D03-56B63B124730.png)

###### 3.2.6 如何写好链表代码

* 指针、引用的含义

有些语言有指针，有些语言是引用；本质上是一样的，都是存储所指对象的地址；

例如链表中某个节点，以单链表来说，需要两个内存块，一个保存当前节点数据，一个为next指针，即保存了下一个节点的内存地址；

![7022ff8262661b300e6e29d74eb8426a](README.resources/53712675-9AC2-4C27-82E3-973E62FE4E08.png)

* 警惕指针丢失和内存泄露

在进行例如插入链表节点时，需要注意指针指向的顺序，例如：

![a8fafa12f31eee8519e18652d55d7525](README.resources/FFFFEBC9-7EFB-4154-82E8-D2D730BAFD3A.png)

如果这样操作：

```
P -> next = M
M -> next = P -> next
```

因为第一步已经把P指针对应节点后继指针指向了M，这样当用 P -> next 想将 H 节点声明为 M 节点的后继节点时候，P->next其实已经不是H了，而是M，这样就导致M指向了自己，导致链表断裂，其实原因在于一开始 P->next 将指向改变的时候就切断了与后面节点的联系，导致新的节点也无法找到后面的节点位置。

正确应该是(相当于先不切断W和H的联系)：

```
M -> next = P -> next
P -> next = M
```

C语言类似的需要手动释放删除的节点内存；而Java这种自动内存管理的不需要；

* 利用哨兵简化难度

引入哨兵节点，head指针一直指向这个哨兵节点；

有哨兵节点的链表叫做带头链表；没有哨兵节点的就叫不带头链表；

带头链表：

![80f69a419447da0938e815d79091c7b4](README.resources/F7402F23-77FA-4860-93EA-7C1187FB074D.png)

* 留意边界条件处理

需要考虑链表为空、只有一个节点、只有两个节点、在处理头尾节点的时候能否正常工作？

* 画图辅助思考

无图无真相

* 多写多练

Talk is cheap, show me your code !

###### 3.2.6 链表代码实战

见代码目录：

[https://github.com/SkyYongFly/DSA/tree/master/src/main/java/com/skylaker/linkedlist](https://github.com/SkyYongFly/DSA/tree/master/src/main/java/com/skylaker/linkedlist)

##### 3.3 栈
###### 3.3.1 基本定义

先进后出，后进先出；是一种操作受限的线性表；只允许一端进行操作；

栈这种结构本质上是对数组、链表的逻辑化封装，底层实现还是要基于数组或者链表本身：

![163decc3796cfd51fe4bfd53ded7b5be](README.resources/5F2DF438-D1D3-49BA-9A38-D08806E9A70A.png)

###### 3.3.2 代码实现

* 基于数组实现的栈

```
package com.skylaker.stack;

/**
 * 基于数组的栈
 * @author skylaker2019@163.com
 * @version V1.0 2019/8/21 11:14 PM
 */
public class StackBasedOnArray {
    // 内部维护一个数组结构
    private String[] arr;
    // 栈最大大小，即数组的设置大小
    private int max;
    // 栈中已有元素个数
    private int num;

    /**
     * 初始化栈，即初始化内部的数组
     * @param max
     */
    public StackBasedOnArray(int max){
        this.arr = new String[max];
        this.max = max;
        this.num = 0;
    }

    /**
     * 入栈操作
     * @return 成功：true ；失败：false
     */
    public boolean push(String item){
        if(num == max){
            // 已有元素个数达到最大数量限制，则说明栈已经满
            return false;
        }

        arr[num] = item;
        num++;

        return true;
    }

    /**
     * 出栈操作
     */
    public String pop(){
        if(0 == num){
            // 已有元素个数为0则说明栈是空的
            return null;
        }

        // 从最上面取值
        String item = arr[num-1];
        num--;

        return item;
    }
}
```

测试数据：

![56d84b11d557776eb102f64ff1b1bbee](README.resources/4261365A-5292-43A1-A7D1-ACEA0B304BBE.png)

输出：

![0254e96eca6fa7744ba99d164695f06b](README.resources/670399E5-5E99-4DEE-B0DD-7176499B342A.png)

如果想遍历的话直接数组倒序遍历即可，避免直接出栈将元素废弃，破坏栈结构。

时间复杂度：O(1)
空间复杂度：O(1)

* 基于链表实现的栈

```
package com.skylaker.stack;

/**
 * 基于链表实现的栈
 * @author skylaker2019@163.com
 * @version V1.0 2019/8/22 12:03 AM
 */
public class StackBasedOnLinkedList {
    // 栈顶结点，该结点也就可直接代表栈
    Node<String> top = null;

    /**
     * 入栈操作
     * @param val
     */
    public void push(String val){
        Node newNode = new Node(val, null);

        if(null == top){
            top = newNode;
        } else {
            // 新的结点成为栈顶元素
            newNode.next = top;
            top = newNode;
        }
    }

    /**
     * 出栈操作
     */
    public String pop(){
        if(null == top){
            return null;
        }

        String val = top.data;
        // 新的栈顶元素后移一个结点
        top = top.next;
        return val;
    }

    /**
     * 获取所有结点值
     */
    public void printAll(){
        if(null == top){
            System.out.println("[空结构]");
        }

        Node p = top;
        while (p != null){
            System.out.print(p.getData() + " ");
            p = p.next;
        }
        System.out.println();
    }

    public static class Node <E> {
        // 结点保存对象
        E data;
        // 后继节点
        Node<E> next;

        Node(E data, Node<E> next){
            this.data = data;
            this.next = next;
        }

        E getData(){
            return this.data;
        }
    }
}
```

测试代码：

![27b106af41ed9ef616e804bc8cb32969](README.resources/63DE1C5A-8109-4825-B6FA-93FCCD01434A.png)

执行结果：

![98250622bc11ed084a52a4dbb45f21df](README.resources/E173F7C5-17A8-411B-BDF6-98F54DC715B0.png)

时间复杂度：O(1)
空间复杂度：O(1)

* 支持动态扩容的栈

如果底层是数组，相当于数组空间不够时候自动扩容，可以再申请一个两倍大小的数组，然后将原有数组复制过去；

如果底层是链表，则本身就支持动态扩容；

##### 3.4 队列
###### 3.4.1 基本定义
一种操作受限的线性表数据结构；和栈一样，也是一种逻辑上抽象的数据结构，本质上可以用数组和链表两种基本数据结构实现；

最基本的两个操作：入队 enqueue()  队尾放一个数据 、出队 dequeue() 队列头部取一个元素；

基本特性：先进先出；后进后出；

![04112728c1c574324a254937d607260d](README.resources/C9EE4915-CC95-454B-90EB-54109CB24B3C.png)

###### 3.4.2 顺序队列
顺序队列：用数组实现的队列

```
package com.skylaker.queue;

/**
 * 顺序队列
 * @author skylaker2019@163.com
 * @version V1.0 2019/9/9 10:04 PM
 */
public class ArrayQueue {
    // 内部数组
    private String[] items;
    // 数组大小：n，即队列大小
    private int n = 0;
    // 队头下标：指向第一个实际元素
    private int head = 0;
    // 队尾下标：指向最后一个元素的后一节点，即入队元素要保存进的位置
    private int tail = 0;

    /**
     * 申请一个大小为 m 的数组
     * @param m
     */
    public ArrayQueue(int m){
        items = new String[m];
        n = m;
    }

    /**
     * 入队操作（不做判空操作，即允许存储空数据）
     * @param item 入队元素
     * @return 成功 true；失败 false
     */
    public boolean enqueue(String item){
        // 判断队列是否已经满
        if(tail == n){
            return false;
        }

        items[tail] = item;
        tail++;
        return true;
    }

    /**
     * 出队操作
     * @return
     */
    public String dequeue(){
        // 判断队列是否为空
        if(head == tail){
            return null;
        }

        String item = items[head];
        head++;
        return item;
    }
}
```

a、b、c、d、e 元素依次入队后，head指向0位置，tail指向5位置：
![5f1ac76594c283609b490fcb4496b20f](README.resources/30386EBC-B432-476F-879A-38AA4005AF03.png)

注意队列元素的内容应该在于队头到队尾之间的元素内容，而不是整个数组，例如出队操作后，只是队头指针向后移动，但是本身出队的元素在数组中是依然存在的；顺序队列是存在于数组上的逻辑数组结构；

两次出队后，队头指向2位置：
![6b9de29dfb42f4113d47194fbc4a76cb](README.resources/EF7574ED-1F5A-4218-8023-8DE078AABACC.png)

产生问题：例如上面的队列，如果继续入队元素，当tail=8时候：
![eb76e1fb616f65c2ab6747c9ce42e156](README.resources/597F3511-17D4-4618-8603-AD29514A01A2.png)
这个时候继续入队，但是队尾已经没有空间了，无法再入队新插入元素，可是队列头明明是有空间的；

解决这个问题，可以在入队的时候进行元素搬移操作，例如上面队列可以后续元素都往前搬移两个位置；但是并不是每次入队都需要，只需要在队尾已经无法插入元素时再迁移元素，降低时间复杂度；

```
/**
     * （带元素空间调整的）入队操作
     * @param item 入队元素
     */
    public boolean enqueueWithMoveItem(String item){
        // 判断队列是否已满
        if(tail == n){
            if(head == 0){
                // 队头在第一个位置，队尾在末尾位置，说明整个队列已经真正满了，无法再入队
                return false;
            }

            // 说明即使队尾已无法入队，但是队头前还有剩余空间，进行元素搬移操作
            for(int i = head; i < tail; i++){
                items[i - head] = items[i];
            }

            // 调整队头和队尾（注意先要调整队尾）
            tail = tail - head;
            head = 0;
        }

        // 再进行入队操作
        items[tail] = item;
        tail++;
        return true;
    }
```

![e5df8c67f560dc787bca883d61e00ab4](README.resources/3F475929-EC99-45E9-955D-7C05F5535BD3.png)

###### 3.4.3 链式队列
链式队列：用链表实现的队列

head指针：指向链表的第一个结点；
tail指针：指向链表最后一个结点；

```
package com.skylaker.queue;

/**
 * 链式队列
 * @author skylaker2019@163.com
 * @version V1.0 2019/9/9 11:17 PM
 */
public class LinkedQueue {
    // 队头
    private Node head = null;
    // 队尾
    private Node tail = null;

    /**
     * 入队
     * @param item
     * @return
     */
    public void enqueue(String item){
        Node node = new Node(item, null);
        if(tail == null){
            head = node;
            tail = node;
        } else {
            tail.next = node;
            tail = node;
        }
    }

    /**
     * 出队
     * @return
     */
    public String dequeue(){
        if(null == head){
            return null;
        }
        String item = head.data;
        head = head.next;

        // 考虑边界情况，如果当期head指向最后一个元素，即和tail位置一样，那么再出队，则head指向下一个结点即空，tail也就自然指向空了
        if(null == head){
            tail = null;
        }
        return item;
    }

    /**
     * 输出元素
     */
    public void print(){
        Node p = head;
        while(null != p){
            System.out.print(p.data + " ");
            p = p.next;
        }
    }


    /**
     * 链式队列结点定义
     */
    public class Node {
        private String data;

        private Node next;

        Node(String data, Node next){
            this.data = data;
            this.next = next;
        }
    }
}
```

![db741e429142a9d4f960023163c6928d](README.resources/66E672FC-B7C8-415E-B0AB-3C8B87F053E1.png)

###### 3.4.4 循环队列
把原有顺序队列，收尾相连，形成一个循环队列；

![4e3bda96221210ce38035a11937b9498](README.resources/87518943-DC3D-41EA-97C2-48420453E741.png)

当前队列tail=2，tail=5，如果继续入队，那么tail依次为5、6、0，这样比顺序队列一个明显优势就是在tail=n时候不需要再移动数组元素，大大降低了入队时间复杂度；

![1bfa758b93b77107f1e7a2ce2b7276d6](README.resources/9FDE8846-FEEF-47F9-A0E4-79479AD5B316.png)

循环队列tail指向的位置不存储元素，所以会浪费一个存储单元空间；

循环队列代码关键：确定好队空和队满的条件；

循环队列满时规律：`（tail + 1）% n = head`

![75387a2cf7d94d955084d869fc0c622a](README.resources/C8D737D6-7ADA-4D54-AA74-D7BC00F3FC72.png)

```
package com.skylaker.queue;

/**
 * 循环队列
 * @author skylaker2019@163.com
 * @version V1.0 2019/9/10 12:30 AM
 */
public class CircularQueue {
    // 数组
    private String[] items;
    // 数组长度
    private int n;
    // 队头下标
    private int head = 0;
    // 队尾下标
    private int tail = 0;

    public CircularQueue(int m){
        items = new String[m];
        n = m;
    }

    /**
     * 入队
     * @param item
     * @return
     */
    public boolean enqueue(String item){
        // 判断队列是否已经满了
        if((tail + 1 ) % n == head){
            return false;
        }

        items[tail] = item;
        tail = (tail + 1) % n;
        return true;
    }

    /**
     * 出队
     * @return
     */
    public String dequeue(){
        if(head == tail){
            return null;
        }

        String item = items[head];
        head = (head + 1) % n;
        return item;
    }

    /**
     * 打印元素
     */
    public void print(){
        if(head == tail){
            System.out.println("队列为空");;
        }

        int p = head;
        while(p != tail){
            System.out.print(items[p] + " ");

            p += 1;
            if(p >= n){
                p -= n;
            }
        }
    }
}
```